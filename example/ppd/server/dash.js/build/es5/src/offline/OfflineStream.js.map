{"version":3,"sources":["../../../../src/offline/OfflineStream.js"],"names":["OfflineStream","config","context","eventBus","events","constants","debug","adapter","offlineStoreController","manifestId","id","startedCb","callbacks","started","progressionCb","progression","finishedCb","finished","updateManifest","updateManifestNeeded","instance","offlineStreamProcessors","startedOfflineStreamProcessors","finishedOfflineStreamProcessors","streamInfo","representationsToUpdate","allMediasInfosList","progressionById","setup","resetInitialSettings","initialize","initStreamInfo","on","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","getDownloadableRepresentations","downloadableRepresentations","video","audio","text","trackKindMap","subtitle","caption","getKind","mediaInfo","kind","roles","length","getAllMediaInfoForType","VIDEO","forEach","item","bitrateList","bitrate","push","bandwidth","width","height","AUDIO","lang","addTextInfo","infos","type","accessibility","FRAGMENTED_TEXT","TEXT","trigger","DOWNLOADABLE_REPRESENTATIONS_LOADED","data","sender","initializeAllMediasInfoList","mediasInfoList","initializeMedia","createOfflineStreamProcessorFor","i","allMediaInfoForType","media","filter","indexOf","createStreamProcessor","streamProcessor","create","completed","onStreamCompleted","onStreamProgression","setConfig","mimeType","stream","message","downloadedSegments","availableSegments","getRepresentationId","segments","allSegments","waitForAllProgress","property","hasOwnProperty","e","repCtrl","getStreamId","currentRepresentation","sp","getRepresentationController","checkIfAllOfflineStreamProcessorsStarted","representations","startOfflineStreamProcessors","getStreamInfo","getStartTime","start","NaN","getDuration","duration","stopOfflineStreamProcessors","stop","deactivate","ln","removeExecutedRequestsBeforeTime","reset","off","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineStream.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport OfflineStreamProcessor from './OfflineStreamProcessor';\n\n/**\n * @module  OfflineStream\n * @description Initialize and Manage Offline Stream for each type\n * @param {Object} config - dependences\n */\nfunction OfflineStream(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const constants = config.constants;\n    const debug = config.debug;\n    const adapter = config.adapter;\n    const offlineStoreController = config.offlineStoreController;\n    const manifestId = config.id;\n    const startedCb = config.callbacks && config.callbacks.started;\n    const progressionCb = config.callbacks && config.callbacks.progression;\n    const finishedCb = config.callbacks && config.callbacks.finished;\n    const updateManifest = config.callbacks && config.callbacks.updateManifestNeeded;\n\n    let instance,\n        offlineStreamProcessors,\n        startedOfflineStreamProcessors,\n        finishedOfflineStreamProcessors,\n        streamInfo,\n        representationsToUpdate,\n        allMediasInfosList,\n        progressionById;\n\n    function setup() {\n        resetInitialSettings();\n    }\n\n    /**\n     * Reset\n     */\n    function resetInitialSettings() {\n        streamInfo = null;\n        offlineStreamProcessors = [];\n        startedOfflineStreamProcessors = 0;\n        finishedOfflineStreamProcessors = 0;\n        allMediasInfosList = [];\n        representationsToUpdate = [];\n        progressionById = {};\n    }\n\n    /**\n     * Initialize offlinestream\n     * @param {Object} initStreamInfo\n     */\n    function initialize(initStreamInfo) {\n        streamInfo = initStreamInfo;\n        eventBus.on(events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n    }\n\n    /**\n     * Creates media bitrate list, so that user will be able to choose the representation he wants to download\n     */\n    function getDownloadableRepresentations() {\n        let downloadableRepresentations = {\n            video: [],\n            audio: [],\n            text: []\n        };\n\n        const trackKindMap = { subtitle: 'subtitles', caption: 'captions' }; //Dash Spec has no \"s\" on end of KIND but HTML needs plural.\n        const getKind = function (mediaInfo) {\n            let kind = (mediaInfo.roles.length > 0) ? trackKindMap[mediaInfo.roles[0]] : trackKindMap.caption;\n            kind = (kind === trackKindMap.caption || kind === trackKindMap.subtitle) ? kind : trackKindMap.caption;\n            return kind;\n        };\n\n        // video\n        let mediaInfo = adapter.getAllMediaInfoForType(streamInfo, constants.VIDEO);\n        if (mediaInfo.length > 0) {\n            mediaInfo.forEach((item) => {\n                item.bitrateList.forEach((bitrate) => {\n                    downloadableRepresentations.video.push({\n                        id: bitrate.id,\n                        bandwidth: bitrate.bandwidth,\n                        width: bitrate.width,\n                        height: bitrate.height\n                    });\n                });\n            });\n        }\n\n        // audio\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, constants.AUDIO);\n        if (mediaInfo.length > 0) {\n            mediaInfo.forEach((item) => {\n                item.bitrateList.forEach((bitrate) => {\n                    downloadableRepresentations.audio.push({\n                        id: bitrate.id,\n                        bandwidth: bitrate.bandwidth,\n                        lang: item.lang\n                    });\n                });\n            });\n        }\n\n        // text\n\n        const addTextInfo = function (infos, type) {\n            if (infos.length > 0) {\n\n                infos.forEach((item) => {\n                    item.bitrateList.forEach((bitrate) => {\n                        downloadableRepresentations.text.push({\n                            id: bitrate.id,\n                            lang: item.lang,\n                            kind: getKind(item),\n                            roles: item.roles,\n                            accessibility: item.accessibility,\n                            type: type\n                        });\n                    });\n                });\n            }\n        };\n\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, constants.FRAGMENTED_TEXT);\n        addTextInfo(mediaInfo, constants.FRAGMENTED_TEXT);\n\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, constants.TEXT);\n        addTextInfo(mediaInfo, constants.TEXT);\n\n        /**\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, constants.MUXED);\n        if (mediaInfo.length > 0) {\n            downloadableRepresentations.push(mediaInfo);\n        }\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, constants.IMAGE);\n        if (mediaInfo.length > 0) {\n            downloadableRepresentations.push(mediaInfo);\n        }\n        */\n\n        eventBus.trigger(events.DOWNLOADABLE_REPRESENTATIONS_LOADED, {\n            data: {\n                id: manifestId,\n                downloadableRepresentations: downloadableRepresentations\n            },\n            sender: this\n        });\n    }\n\n\n    /**\n     * Initialize with choosen representations by user\n     * @param {Object} mediasInfoList\n     */\n    function initializeAllMediasInfoList(mediasInfoList) {\n        allMediasInfosList = mediasInfoList;\n        initializeMedia(streamInfo);\n    }\n\n    /**\n     * Initialize media for each type\n     * @param {Object} streamInfo\n     */\n    function initializeMedia(streamInfo) {\n        createOfflineStreamProcessorFor(constants.VIDEO,streamInfo);\n        createOfflineStreamProcessorFor(constants.AUDIO,streamInfo);\n        createOfflineStreamProcessorFor(constants.FRAGMENTED_TEXT,streamInfo);\n        createOfflineStreamProcessorFor(constants.TEXT,streamInfo);\n\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\n            offlineStreamProcessors[i].initialize();\n        }\n        /*\n        createOfflineStreamProcessorFor(constants.MUXED,streamInfo);\n        createOfflineStreamProcessorFor(constants.IMAGE,streamInfo);\n        */\n    }\n\n    function createOfflineStreamProcessorFor(type, streamInfo) {\n        // filter mediaInfo according to choosen representation id\n        let allMediaInfoForType = adapter.getAllMediaInfoForType(streamInfo, type);\n        allMediaInfoForType.forEach((media) => {\n            media.bitrateList = media.bitrateList.filter((bitrate) => {\n                if (allMediasInfosList[type] && allMediasInfosList[type].indexOf(bitrate.id) !== -1) {\n                    return true;\n                }\n                return false;\n            });\n        });\n\n        allMediaInfoForType = allMediaInfoForType.filter((media) => {\n            return (media.bitrateList && media.bitrateList.length > 0);\n        });\n\n        // cration of an offline stream processor for each choosen representation\n        allMediaInfoForType.forEach((mediaInfo) => {\n            if (mediaInfo.bitrateList) {\n                mediaInfo.bitrateList.forEach((bitrate) => {\n                    createStreamProcessor(mediaInfo, bitrate);\n                });\n            }\n        });\n        return allMediaInfoForType;\n    }\n\n    function createStreamProcessor (mediaInfo, bitrate) {\n\n        let streamProcessor = OfflineStreamProcessor(context).create({\n            id: manifestId,\n            callbacks: {\n                completed: onStreamCompleted,\n                progression: onStreamProgression\n            },\n            debug: debug,\n            events: events,\n            eventBus: eventBus,\n            constants: constants\n        });\n        streamProcessor.setConfig({\n            type: mediaInfo.type,\n            mimeType: mediaInfo.mimeType,\n            mediaInfo: mediaInfo,\n            bitrate: bitrate,\n            adapter: adapter,\n            stream: instance,\n            offlineStoreController: offlineStoreController\n        });\n        offlineStreamProcessors.push(streamProcessor);\n\n        progressionById[bitrate.id] = null;\n    }\n\n    function onStreamCompleted() {\n        finishedOfflineStreamProcessors++;\n        if (finishedOfflineStreamProcessors === offlineStreamProcessors.length) {\n            finishedCb({sender: this, id: manifestId, message: 'Downloading has been successfully completed for this stream !'});\n        }\n    }\n\n    function onStreamProgression(streamProcessor, downloadedSegments, availableSegments ) {\n        progressionById[streamProcessor.getRepresentationId()] = {\n            downloadedSegments,\n            availableSegments\n        };\n\n        let segments = 0;\n        let allSegments = 0;\n        let waitForAllProgress;\n        for (var property in progressionById) {\n            if (progressionById.hasOwnProperty(property)) {\n                if (progressionById[property] === null) {\n                    waitForAllProgress = true;\n                } else {\n                    segments += progressionById[property].downloadedSegments;\n                    allSegments += progressionById[property].availableSegments;\n                }\n            }\n        }\n\n        if (!waitForAllProgress && progressionCb) {\n            // all progression have been started, we can compute global progression\n            if (allSegments > 0) {\n                progressionCb(instance, segments, allSegments);\n            }\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        let repCtrl = e.sender;\n        if (!streamInfo || repCtrl.getStreamId() !== streamInfo.id) return;\n\n        if (e.currentRepresentation.segments && e.currentRepresentation.segments.length > 0) {\n            representationsToUpdate.push(e.currentRepresentation);\n        }\n\n        let sp;\n        // data are ready fr stream processor, let's start download\n        for (let i = 0; i < offlineStreamProcessors.length; i++ ) {\n            if (offlineStreamProcessors[i].getRepresentationController() === repCtrl) {\n                sp = offlineStreamProcessors[i];\n                break;\n            }\n        }\n\n        if (sp) {\n            checkIfAllOfflineStreamProcessorsStarted();\n        }\n    }\n\n    function checkIfAllOfflineStreamProcessorsStarted() {\n        startedOfflineStreamProcessors++;\n        if (startedOfflineStreamProcessors === offlineStreamProcessors.length) {\n            startedCb({sender: this, id: manifestId, message: 'Downloading started for this stream !'});\n\n            if (representationsToUpdate.length > 0) {\n                updateManifest({sender: this, id: manifestId, representations: representationsToUpdate });\n            } else {\n                startOfflineStreamProcessors();\n            }\n        }\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function getStartTime() {\n        return streamInfo ? streamInfo.start : NaN;\n    }\n\n    function getDuration() {\n        return streamInfo ? streamInfo.duration : NaN;\n    }\n\n    /**\n     * Stop offline stream processors\n     */\n    function stopOfflineStreamProcessors() {\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\n            offlineStreamProcessors[i].stop();\n        }\n    }\n\n    /**\n     * Start offline stream processors\n     */\n    function startOfflineStreamProcessors() {\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\n            offlineStreamProcessors[i].start();\n        }\n    }\n\n    function deactivate() {\n        let ln = offlineStreamProcessors ? offlineStreamProcessors.length : 0;\n        for (let i = 0; i < ln; i++) {\n            offlineStreamProcessors[i].removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\n            offlineStreamProcessors[i].reset();\n        }\n    }\n\n    /**\n     * Reset\n     */\n    function reset() {\n        stopOfflineStreamProcessors();\n        deactivate();\n        resetInitialSettings();\n\n        eventBus.off(events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n    }\n\n    instance = {\n        initialize: initialize,\n        getDownloadableRepresentations: getDownloadableRepresentations,\n        initializeAllMediasInfoList: initializeAllMediasInfoList,\n        getStreamInfo: getStreamInfo,\n        stopOfflineStreamProcessors: stopOfflineStreamProcessors,\n        startOfflineStreamProcessors: startOfflineStreamProcessors,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nOfflineStream.__dashjs_factory_name = 'OfflineStream';\nexport default dashjs.FactoryMaker.getClassFactory(OfflineStream); /* jshint ignore:line */\n"]}