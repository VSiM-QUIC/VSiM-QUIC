{"version":3,"sources":["../../../../src/offline/OfflineStreamProcessor.js"],"names":["OfflineStreamProcessor","config","eventBus","events","debug","constants","manifestId","id","completedCb","callbacks","completed","progressCb","progression","instance","adapter","logger","indexHandler","representationController","type","mimeType","fragmentModel","mediaInfo","bitrate","updating","offlineStoreController","downloadedSegments","isInitialized","isStopped","stream","setConfig","setup","resetInitialSettings","getLogger","on","STREAM_COMPLETED","onStreamCompleted","FRAGMENT_LOADING_COMPLETED","onFragmentLoadingCompleted","isInitRequest","request","e","sender","isInit","suffix","index","fragmentName","representationId","storeFragment","response","then","setRepresentationCurrentState","downloaded","error","serviceLocation","executeRequest","download","info","stop","getRepresentationController","getRepresentationId","getCurrentRepresentation","initializeDownloader","updateRepresentation","setDashElements","handler","fragModel","repController","initialize","trigger","OfflineEvents","DASH_ELEMENTS_CREATION_NEEDED","streamInfo","getStreamInfo","removeExecutedRequestsBeforeTime","time","getInitRequest","getMediaInfo","getNextRequest","getNextSegmentRequest","start","Error","getRepresentationCurrentState","state","setCurrentIndex","catch","isNaN","updateProgression","url","voRepresentations","getVoRepresentations","quality","findIndex","representation","VIDEO","AUDIO","TEXT","FRAGMENTED_TEXT","updateData","isUpdating","getType","getAvailableSegmentsNumber","availableSegmentsNumber","reset","off","__dashjs_factory_name","factory","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineStreamProcessor.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport OfflineEvents from './events/OfflineEvents';\n\n/**\n * @module OfflineStreamProcessor\n * @param {object} config configuration\n * @description Arrange downloading for each type\n */\nfunction OfflineStreamProcessor(config) {\n\n    config = config || {};\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const debug = config.debug;\n    const constants = config.constants;\n    const manifestId = config.id;\n    const completedCb = config.callbacks && config.callbacks.completed;\n    const progressCb = config.callbacks && config.callbacks.progression;\n\n    let instance,\n        adapter,\n        logger,\n        indexHandler,\n        representationController,\n        type,\n        mimeType,\n        fragmentModel,\n        mediaInfo,\n        bitrate,\n        updating,\n        offlineStoreController,\n        downloadedSegments,\n        isInitialized,\n        isStopped,\n        stream;\n\n    function setConfig(config) {\n\n        if (!config) return;\n\n        if (config.type) {\n            type = config.type;\n        }\n\n        if (config.stream) {\n            stream = config.stream;\n        }\n\n        if (config.mimeType) {\n            mimeType = config.mimeType;\n        }\n\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n\n        if (config.mediaInfo) {\n            mediaInfo = config.mediaInfo;\n        }\n\n        if (config.bitrate) {\n            bitrate = config.bitrate;\n        }\n\n        if (config.offlineStoreController) {\n            offlineStoreController = config.offlineStoreController;\n        }\n    }\n\n    function setup() {\n        resetInitialSettings();\n        logger = debug.getLogger(instance);\n        eventBus.on(events.STREAM_COMPLETED, onStreamCompleted, instance);\n        eventBus.on(events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, instance);\n    }\n\n    function isInitRequest(request) {\n        return request.type === 'InitializationSegment';\n    }\n\n    function onFragmentLoadingCompleted(e) {\n        if (e.sender !== fragmentModel) {\n            return;\n        }\n\n        if (e.request !== null) {\n            let isInit = isInitRequest(e.request);\n            let suffix = isInit ? 'init' : e.request.index;\n            let fragmentName = e.request.representationId + '_' + suffix;\n            offlineStoreController.storeFragment(manifestId, fragmentName, e.response)\n            .then(() => {\n                if (!isInit) {\n                    // store current index and downloadedSegments number\n                    offlineStoreController.setRepresentationCurrentState(manifestId, e.request.representationId, {\n                        index: e.request.index,\n                        downloaded: downloadedSegments\n                    } );\n                }\n            });\n        }\n\n        if (e.error && e.request.serviceLocation && !isStopped) {\n            fragmentModel.executeRequest(e.request);\n        } else {\n            downloadedSegments++;\n            download();\n        }\n    }\n\n    function onStreamCompleted(e) {\n        if (e.fragmentModel !== fragmentModel) {\n            return;\n        }\n        logger.info(`[${manifestId}] Stream is complete`);\n        stop();\n        completedCb();\n    }\n\n    function getRepresentationController () {\n        return representationController;\n    }\n\n    function getRepresentationId() {\n        return representationController.getCurrentRepresentation().id;\n    }\n\n    /**\n     * Stops download of fragments\n     * @memberof OfflineStreamProcessor#\n     */\n    function stop() {\n        if (isStopped) {\n            return;\n        }\n        isStopped = true;\n    }\n\n    function initializeDownloader () {\n        updateRepresentation(mediaInfo);\n    }\n\n    function setDashElements(handler, fragModel, repController) {\n        indexHandler = handler;\n        indexHandler.initialize(false);\n\n        fragmentModel = fragModel;\n        representationController = repController;\n\n        initializeDownloader();\n    }\n\n    /**\n     * Initialization\n     * @memberof OfflineStreamProcessor#\n    */\n    function initialize() {\n        eventBus.trigger(OfflineEvents.DASH_ELEMENTS_CREATION_NEEDED, {sender: instance, config: {type: type,\n            mimeType: mimeType,\n            streamInfo: getStreamInfo()}} );\n    }\n\n    function removeExecutedRequestsBeforeTime(time) {\n        if (fragmentModel) {\n            fragmentModel.removeExecutedRequestsBeforeTime(time);\n        }\n    }\n\n    /**\n     * Execute init request for the represenation\n     * @memberof OfflineStreamProcessor#\n    */\n    function getInitRequest() {\n        if (!representationController.getCurrentRepresentation()) {\n            return null;\n        }\n\n        return indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation());\n    }\n\n    /**\n     * Get next request\n     * @memberof OfflineStreamProcessor#\n    */\n    function getNextRequest() {\n        return indexHandler.getNextSegmentRequest(getMediaInfo(), representationController.getCurrentRepresentation());\n    }\n\n    /**\n     * Start download\n     * @memberof OfflineStreamProcessor#\n    */\n    function start() {\n        if (representationController) {\n            if (!representationController.getCurrentRepresentation()) {\n                throw new Error('Start denied to OfflineStreamProcessor');\n            }\n            isStopped = false;\n\n            offlineStoreController.getRepresentationCurrentState(manifestId, representationController.getCurrentRepresentation().id)\n            .then((state) => {\n                if (state) {\n                    indexHandler.setCurrentIndex(state.index);\n                    downloadedSegments = state.downloaded;\n                }\n                download();\n            }).catch(() => {\n                // start from beginining\n                download();\n            });\n        }\n    }\n\n    /**\n     * Performs download of fragment according to type\n     * @memberof OfflineStreamProcessor#\n    */\n    function download() {\n        if (isStopped) {\n            return;\n        }\n\n        if (isNaN(representationController.getCurrentRepresentation())) {\n            let request = null;\n            if (!isInitialized) {\n                request = getInitRequest();\n                isInitialized = true;\n            } else {\n                request = getNextRequest();\n\n                // update progression : done here because availableSegmentsNumber is done in getNextRequest from dash handler\n                updateProgression();\n            }\n\n            if (request) {\n                logger.info(`[${manifestId}] download request : ${request.url}`);\n                fragmentModel.executeRequest(request);\n            } else {\n                logger.info(`[${manifestId}] no request to be downloaded`);\n            }\n        }\n    }\n\n    /**\n     * Update representation\n     * @param {Object} mediaInfo - mediaInfo\n     * @memberof OfflineStreamProcessor#\n     */\n    function updateRepresentation(mediaInfo) {\n        updating = true;\n\n        let voRepresentations = adapter.getVoRepresentations(mediaInfo);\n\n        // get representation VO according to id.\n        let quality = voRepresentations.findIndex((representation) => {\n            return representation.id === bitrate.id;\n        });\n\n        if (type !== constants.VIDEO && type !== constants.AUDIO  && type !== constants.TEXT && type !== constants.FRAGMENTED_TEXT) {\n            updating = false;\n            return;\n        }\n\n        representationController.updateData(null, voRepresentations, type, quality);\n    }\n\n    function getStreamInfo() {\n        return stream ? stream.getStreamInfo() : null;\n    }\n\n    function isUpdating() {\n        return updating;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getMediaInfo() {\n        return mediaInfo;\n    }\n\n    function getAvailableSegmentsNumber() {\n        return representationController.getCurrentRepresentation().availableSegmentsNumber + 1; // do not forget init segment\n    }\n\n    function updateProgression () {\n        if (progressCb) {\n            progressCb(instance, downloadedSegments, getAvailableSegmentsNumber());\n        }\n    }\n\n    function resetInitialSettings() {\n        isInitialized = false;\n        downloadedSegments = 0;\n        mimeType = null;\n        mediaInfo = null;\n        bitrate = null;\n        updating = false;\n        type = null;\n        stream = null;\n    }\n\n    /**\n     * Reset\n     * @memberof OfflineStreamProcessor#\n    */\n    function reset() {\n        resetInitialSettings();\n        indexHandler.reset();\n\n        eventBus.off(events.STREAM_COMPLETED, onStreamCompleted, instance);\n        eventBus.off(events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, instance);\n    }\n\n    instance = {\n        initialize: initialize,\n        setConfig: setConfig,\n        getStreamInfo: getStreamInfo,\n        getMediaInfo: getMediaInfo,\n        getRepresentationController: getRepresentationController,\n        removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime,\n        getType: getType,\n        getRepresentationId: getRepresentationId,\n        isUpdating: isUpdating,\n        start: start,\n        stop: stop,\n        getAvailableSegmentsNumber: getAvailableSegmentsNumber,\n        setDashElements: setDashElements,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\nOfflineStreamProcessor.__dashjs_factory_name = 'OfflineStreamProcessor';\nconst factory = dashjs.FactoryMaker.getClassFactory(OfflineStreamProcessor); /* jshint ignore:line */\nexport default factory;\n"]}