{"version":3,"sources":["../../../../src/offline/OfflineDownload.js"],"names":["OfflineDownload","config","manifestLoader","adapter","offlineStoreController","manifestId","id","eventBus","errHandler","events","debug","manifestUpdater","baseURLController","constants","dashConstants","urlUtils","context","instance","logger","_manifestURL","_offlineURL","_xmlManifest","_streams","_manifest","_isDownloadingStatus","_isComposed","_representationsToUpdate","_indexDBManifestParser","_progressionById","_progression","_status","setup","getLogger","initialize","undefined","getId","getOfflineUrl","getManifestUrl","getStatus","setInitialState","state","url","progress","originalUrl","status","downloadFromUrl","OfflineConstants","OFFLINE_SCHEME","OFFLINE_STATUS_CREATED","setupOfflineEvents","offlineManifest","createOfflineManifest","initDownload","load","on","MANIFEST_UPDATED","onManifestUpdated","ORIGINAL_MANIFEST_LOADED","onOriginalManifestLoaded","setupIndexedDBEvents","ERROR","onError","isDownloading","e","error","manifest","err","OFFLINE_STATUS_ERROR","code","OfflineErrors","OFFLINE_ERROR","message","data","onDownloadingStarted","OFFLINE_STATUS_STARTED","setDownloadingStatus","then","trigger","DOWNLOADING_STARTED","OnStreamProgression","stream","downloaded","available","getStreamInfo","segments","allSegments","waitForAllProgress","property","hasOwnProperty","getManifestById","item","updateOfflineManifest","onDownloadingFinished","OFFLINE_STATUS_FINISHED","DOWNLOADING_FINISHED","resetDownload","onManifestUpdateNeeded","representations","length","parse","parsedManifest","i","ln","startOfflineStreamProcessors","catch","composeStreams","updatePeriods","streamsInfo","getStreamsInfo","streamInfo","create","callbacks","started","progression","finished","updateManifestNeeded","push","info","getDownloadableRepresentations","forEach","createFragmentStore","off","originalManifest","type","DYNAMIC","Period_asArray","STREAMS_COMPOSED","initializeAllMediasInfoList","selectedRepresentations","formatSelectedRepresentations","ret","VIDEO","AUDIO","TEXT","FRAGMENTED_TEXT","video","audio","text","startDownload","rep","saveSelectedRepresentations","generateOfflineManifest","XMLManifest","allMediaInfos","originalURL","Promise","reject","stopDownload","stopOfflineStreamProcessors","OFFLINE_STATUS_STOPPED","DOWNLOADING_STOPPED","sender","deleteDownload","resumeDownload","selectedRepresentation","selected","getDownloadProgression","Math","round","reset","resetIndexedDBEvents","INDEXEDDB_QUOTA_EXCEED_ERROR","INDEXEDDB_INVALID_STATE_ERROR","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineDownload.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport OfflineConstants from './constants/OfflineConstants';\nimport OfflineStream from './OfflineStream';\nimport OfflineIndexDBManifestParser from './utils/OfflineIndexDBManifestParser';\nimport OfflineErrors from './errors/OfflineErrors';\n\n/**\n * @class OfflineDownload\n */\nfunction OfflineDownload(config) {\n    config = config || {};\n\n    const manifestLoader = config.manifestLoader;\n    const adapter = config.adapter;\n    const offlineStoreController = config.offlineStoreController;\n    const manifestId = config.id;\n    const eventBus = config.eventBus;\n    const errHandler = config.errHandler;\n    const events = config.events;\n    const debug = config.debug;\n    const manifestUpdater = config.manifestUpdater;\n    const baseURLController = config.baseURLController;\n    const constants = config.constants;\n    const dashConstants = config.dashConstants;\n    const urlUtils = config.urlUtils;\n\n    const context = this.context;\n\n    let instance,\n        logger,\n        _manifestURL,\n        _offlineURL,\n        _xmlManifest,\n        _streams,\n        _manifest,\n        _isDownloadingStatus,\n        _isComposed,\n        _representationsToUpdate,\n        _indexDBManifestParser,\n        _progressionById,\n        _progression,\n        _status;\n\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        manifestUpdater.initialize();\n        _streams = [];\n        _isDownloadingStatus = false;\n        _isComposed = false;\n        _progressionById = {};\n        _progression = 0;\n        _status = undefined;\n    }\n\n    function getId() {\n        return manifestId;\n    }\n\n    function getOfflineUrl () {\n        return _offlineURL;\n    }\n\n    function getManifestUrl () {\n        return _manifestURL;\n    }\n\n    function getStatus () {\n        return _status;\n    }\n\n    function setInitialState(state) {\n        _offlineURL = state.url;\n        _progression = state.progress;\n        _manifestURL = state.originalUrl;\n        _status = state.status;\n    }\n\n    /**\n     * Download a stream, from url of manifest\n     * @param {string} url\n     * @instance\n     */\n    function downloadFromUrl(url) {\n        _manifestURL = url;\n        _offlineURL = `${OfflineConstants.OFFLINE_SCHEME}://${manifestId}`;\n        _status = OfflineConstants.OFFLINE_STATUS_CREATED;\n        setupOfflineEvents();\n        let offlineManifest = {\n            'fragmentStore': manifestId,\n            'status': _status,\n            'manifestId': manifestId,\n            'url': _offlineURL,\n            'originalURL': url\n        };\n        return createOfflineManifest(offlineManifest);\n    }\n\n    function initDownload() {\n        manifestLoader.load(_manifestURL);\n        _isDownloadingStatus = true;\n    }\n\n    function setupOfflineEvents() {\n        eventBus.on(events.MANIFEST_UPDATED, onManifestUpdated, instance);\n        eventBus.on(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\n        setupIndexedDBEvents();\n    }\n\n    function setupIndexedDBEvents() {\n        eventBus.on(events.ERROR, onError, instance);\n    }\n\n    function isDownloading() {\n        return _isDownloadingStatus;\n    }\n\n    function onManifestUpdated(e) {\n        if (_isComposed) {\n            return;\n        }\n        if (!e.error) {\n            try {\n                _manifest = e.manifest;\n            } catch (err) {\n                _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n                errHandler.error({\n                    code: OfflineErrors.OFFLINE_ERROR,\n                    message: err.message,\n                    data: {\n                        id: manifestId,\n                        status: _status\n                    }\n                });\n            }\n        }\n    }\n\n    function onDownloadingStarted(e) {\n        if (e.id !== manifestId) {\n            return;\n        }\n        if (!e.error && manifestId !== null) {\n            _status = OfflineConstants.OFFLINE_STATUS_STARTED;\n            offlineStoreController.setDownloadingStatus(manifestId, _status).then(function () {\n                eventBus.trigger(events.DOWNLOADING_STARTED, {id: manifestId, message: 'Downloading started for this stream !'});\n            });\n        } else {\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: 'Cannot start download ',\n                data: {\n                    id: manifestId,\n                    status: _status,\n                    error: e.error\n                }\n            });\n        }\n    }\n\n    function OnStreamProgression(stream, downloaded, available) {\n\n        _progressionById[stream.getStreamInfo().id] = {\n            downloaded,\n            available\n        };\n\n        let segments = 0;\n        let allSegments = 0;\n        let waitForAllProgress;\n        for (var property in _progressionById) {\n            if (_progressionById.hasOwnProperty(property)) {\n                if (_progressionById[property] === null) {\n                    waitForAllProgress = true;\n                } else {\n                    segments += _progressionById[property].downloaded;\n                    allSegments += _progressionById[property].available;\n                }\n            }\n        }\n\n        if (!waitForAllProgress) {\n            // all progression have been started, we can compute global progression\n            _progression = segments / allSegments;\n\n            // store progression\n            offlineStoreController.getManifestById(manifestId)\n                .then((item) => {\n                    item.progress = _progression;\n                    return updateOfflineManifest(item);\n                });\n        }\n    }\n\n    function onDownloadingFinished(e) {\n        if (e.id !== manifestId) {\n            return;\n        }\n        if (!e.error && manifestId !== null) {\n            _status = OfflineConstants.OFFLINE_STATUS_FINISHED;\n            offlineStoreController.setDownloadingStatus(manifestId, _status)\n            .then(function () {\n                eventBus.trigger(events.DOWNLOADING_FINISHED, {id: manifestId, message: 'Downloading has been successfully completed for this stream !'});\n                resetDownload();\n            });\n        } else {\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: 'Error finishing download ',\n                data: {\n                    id: manifestId,\n                    status: _status,\n                    error: e.error\n                }\n            });\n        }\n    }\n\n    function onManifestUpdateNeeded(e) {\n        if (e.id !== manifestId) {\n            return;\n        }\n\n        _representationsToUpdate = e.representations;\n\n        if (_representationsToUpdate.length > 0) {\n            _indexDBManifestParser.parse(_xmlManifest, _representationsToUpdate).then(function (parsedManifest) {\n                if (parsedManifest !== null && manifestId !== null) {\n                    offlineStoreController.getManifestById(manifestId)\n                    .then((item) => {\n                        item.manifest = parsedManifest;\n                        return updateOfflineManifest(item);\n                    })\n                    .then( function () {\n                        for (let i = 0, ln = _streams.length; i < ln; i++) {\n                            _streams[i].startOfflineStreamProcessors();\n                        }\n                    });\n                } else {\n                    throw 'falling parsing offline manifest';\n                }\n            }).catch(function (err) {\n                throw err;\n            });\n        }\n    }\n\n    function composeStreams() {\n        try {\n            adapter.updatePeriods(_manifest);\n            baseURLController.initialize(_manifest);\n            const streamsInfo = adapter.getStreamsInfo();\n            if (streamsInfo.length === 0) {\n                _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n                errHandler.error({\n                    code: OfflineErrors.OFFLINE_ERROR,\n                    message: 'Cannot download - no streams',\n                    data: {\n                        id: manifestId,\n                        status: _status\n                    }\n                });\n            }\n            for (let i = 0, ln = streamsInfo.length; i < ln; i++) {\n                const streamInfo = streamsInfo[i];\n                let stream = OfflineStream(context).create({\n                    id: manifestId,\n                    callbacks: {\n                        started: onDownloadingStarted,\n                        progression: OnStreamProgression,\n                        finished: onDownloadingFinished,\n                        updateManifestNeeded: onManifestUpdateNeeded\n                    },\n                    constants: constants,\n                    eventBus: eventBus,\n                    events: events,\n                    debug: debug,\n                    adapter: adapter,\n                    offlineStoreController: offlineStoreController\n                });\n                _streams.push(stream);\n\n                // initialise stream and get downloadable representations\n                stream.initialize(streamInfo);\n                _progressionById[streamInfo.id] = null;\n            }\n            _isComposed = true;\n        } catch (e) {\n            logger.info(e);\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: e.message,\n                data: {\n                    id: manifestId,\n                    status: _status,\n                    error: e.error\n                }\n            });\n        }\n    }\n\n    function getDownloadableRepresentations() {\n        _streams.forEach(stream => {\n            stream.getDownloadableRepresentations();\n        });\n    }\n\n    /**\n     * Init databsse to store fragments\n     * @param {number} manifestId\n     * @instance\n     */\n    function createFragmentStore(manifestId) {\n        return offlineStoreController.createFragmentStore(manifestId);\n    }\n\n    /**\n     * Store in database the string representation of offline manifest (with only downloaded representations)\n     * @param {object} offlineManifest\n     * @instance\n     */\n    function createOfflineManifest(offlineManifest) {\n        return offlineStoreController.createOfflineManifest(offlineManifest);\n    }\n\n    /**\n     * Store in database the string representation of offline manifest (with only downloaded representations)\n     * @param {object} offlineManifest\n     * @instance\n     */\n    function updateOfflineManifest(offlineManifest) {\n        return offlineStoreController.updateOfflineManifest(offlineManifest);\n    }\n\n    /**\n     * Triggered when manifest is loaded from internet.\n     * @param {Object[]} e\n     */\n    function onOriginalManifestLoaded(e) {\n        // unregister form event\n        eventBus.off(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\n\n        _xmlManifest = e.originalManifest;\n\n        if (_manifest.type === dashConstants.DYNAMIC) {\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: 'Cannot handle DYNAMIC manifest',\n                data: {\n                    id: manifestId,\n                    status: _status\n                }\n            });\n            logger.error('Cannot handle DYNAMIC manifest');\n\n            return;\n        }\n\n        if (_manifest.Period_asArray.length > 1) {\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: 'MultiPeriod manifest are not yet supported',\n                data: {\n                    id: manifestId,\n                    status: _status\n                }\n            });\n            logger.error('MultiPeriod manifest are not yet supported');\n\n            return;\n        }\n\n        // save original manifest (for resume)\n\n        // initialise offline streams\n        composeStreams(_manifest);\n\n        // get downloadable representations\n        getDownloadableRepresentations();\n\n        eventBus.trigger(events.STREAMS_COMPOSED);\n    }\n\n    function initializeAllMediasInfoList(selectedRepresentations) {\n        for (let i = 0; i < _streams.length; i++) {\n            _streams[i].initializeAllMediasInfoList(selectedRepresentations);\n        }\n    }\n\n    function formatSelectedRepresentations(selectedRepresentations) {\n        let ret = {\n        };\n\n        ret[constants.VIDEO] = [];\n        ret[constants.AUDIO] = [];\n        ret[constants.TEXT] = [];\n        ret[constants.FRAGMENTED_TEXT] = [];\n        selectedRepresentations.video.forEach(item => {\n            ret[constants.VIDEO].push(item.id);\n        });\n        selectedRepresentations.audio.forEach(item => {\n            ret[constants.AUDIO].push(item.id);\n        });\n        selectedRepresentations.text.forEach(item => {\n            ret[item.type].push(item.id);\n        });\n\n        return ret;\n    }\n\n    function startDownload(selectedRepresentations) {\n        try {\n            let rep = formatSelectedRepresentations(selectedRepresentations);\n\n            offlineStoreController.saveSelectedRepresentations(manifestId, rep)\n            .then(() => {\n                return createFragmentStore(manifestId);\n            })\n            .then(() => {\n                return generateOfflineManifest(_xmlManifest, rep, manifestId);\n            })\n            .then(function () {\n                initializeAllMediasInfoList(rep);\n            });\n        } catch (err) {\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\n            errHandler.error({\n                code: OfflineErrors.OFFLINE_ERROR,\n                message: err.message,\n                data: {\n                    id: manifestId,\n                    status: _status\n                }\n            });\n        }\n    }\n\n    /**\n     * Create the parser used to convert original manifest in offline manifest\n     * Creates a JSON object that will be stored in database\n     * @param {string} XMLManifest\n     * @param {Object[]} selectedRepresentations\n     * @param {number} manifestId\n     * @instance\n     */\n    function generateOfflineManifest(XMLManifest, selectedRepresentations, manifestId) {\n        _indexDBManifestParser = OfflineIndexDBManifestParser(context).create({\n            manifestId: manifestId,\n            allMediaInfos: selectedRepresentations,\n            debug: debug,\n            dashConstants: dashConstants,\n            constants: constants,\n            urlUtils: urlUtils\n        });\n\n        return _indexDBManifestParser.parse(XMLManifest).then(function (parsedManifest) {\n            if (parsedManifest !== null && manifestId !== null) {\n                return offlineStoreController.getManifestById(manifestId)\n                .then((item) => {\n                    item.originalURL = _manifest.url;\n                    item.originalManifest = _manifest;\n                    item.manifest = parsedManifest;\n                    return updateOfflineManifest(item);\n                });\n            } else {\n                return Promise.reject('falling parsing offline manifest');\n            }\n        }).catch(function (err) {\n            return Promise.reject(err);\n        });\n    }\n\n    /**\n     * Stops downloading of fragments\n     * @instance\n     */\n    function stopDownload() {\n        if (manifestId !== null && isDownloading()) {\n            for (let i = 0, ln = _streams.length; i < ln; i++) {\n                _streams[i].stopOfflineStreamProcessors();\n            }\n\n            // remove streams\n            _streams = [];\n\n            _isComposed = false;\n\n            _status = OfflineConstants.OFFLINE_STATUS_STOPPED;\n            // update status\n            offlineStoreController.setDownloadingStatus(manifestId, _status).then(function () {\n                eventBus.trigger(events.DOWNLOADING_STOPPED, {\n                    sender: this,\n                    id: manifestId,\n                    status: _status,\n                    message: 'Downloading has been stopped for this stream !'\n                });\n                _isDownloadingStatus = false;\n            });\n        }\n    }\n\n    /**\n     * Delete an offline manifest (and all of its data)\n     * @instance\n     */\n    function deleteDownload() {\n        stopDownload();\n    }\n\n    /**\n     * Resume download of a stream\n     * @instance\n     */\n    function resumeDownload() {\n        if (!isDownloading()) {\n            _isDownloadingStatus = true;\n\n            let selectedRepresentation;\n\n            offlineStoreController.getManifestById(manifestId)\n            .then((item) => {\n                _manifest = item.originalManifest;\n                selectedRepresentation = item.selected;\n\n                composeStreams(_manifest);\n                eventBus.trigger(events.STREAMS_COMPOSED);\n\n                return createFragmentStore(manifestId);\n            }). then(() => {\n                initializeAllMediasInfoList(selectedRepresentation);\n            });\n        }\n    }\n\n    /**\n     * Compute the progression of download\n     * @instance\n     */\n    function getDownloadProgression() {\n        return Math.round(_progression * 100);\n    }\n\n    /**\n     * Reset events listeners\n     * @instance\n     */\n    function resetDownload() {\n        for (let i = 0, ln = _streams.length; i < ln; i++) {\n            _streams[i].reset();\n        }\n        _indexDBManifestParser = null;\n        _isDownloadingStatus = false;\n        _streams = [];\n        eventBus.off(events.MANIFEST_UPDATED, onManifestUpdated, instance);\n        eventBus.off(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\n        resetIndexedDBEvents();\n    }\n\n    function onError(e) {\n        if ( e.error.code === OfflineErrors.INDEXEDDB_QUOTA_EXCEED_ERROR ||\n             e.error.code === OfflineErrors.INDEXEDDB_INVALID_STATE_ERROR ) {\n            stopDownload();\n        }\n    }\n\n    function resetIndexedDBEvents() {\n        eventBus.on(events.ERROR, onError, instance);\n    }\n\n    /**\n     * Reset\n     * @instance\n     */\n    function reset() {\n        if (isDownloading()) {\n            resetDownload();\n        }\n        baseURLController.reset();\n        manifestUpdater.reset();\n    }\n\n    instance = {\n        reset: reset,\n        getId: getId,\n        getOfflineUrl: getOfflineUrl,\n        getManifestUrl: getManifestUrl,\n        getStatus: getStatus,\n        setInitialState: setInitialState,\n        initDownload: initDownload,\n        downloadFromUrl: downloadFromUrl,\n        startDownload: startDownload,\n        stopDownload: stopDownload,\n        resumeDownload: resumeDownload,\n        deleteDownload: deleteDownload,\n        getDownloadProgression: getDownloadProgression,\n        isDownloading: isDownloading,\n        resetDownload: resetDownload\n    };\n\n    setup();\n\n    return instance;\n}\n\nOfflineDownload.__dashjs_factory_name = 'OfflineDownload';\nexport default dashjs.FactoryMaker.getClassFactory(OfflineDownload); /* jshint ignore:line */\n"]}