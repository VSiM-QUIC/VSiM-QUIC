{"version":3,"sources":["../../../../../src/streaming/controllers/ScheduleController.js"],"names":["ScheduleController","config","context","eventBus","getInstance","adapter","dashMetrics","timelineConverter","mediaPlayerModel","abrController","playbackController","streamController","textController","type","streamProcessor","mediaController","settings","instance","logger","fragmentModel","currentRepresentationInfo","initialRequest","isStopped","isFragmentProcessingInProgress","timeToLoadDelay","scheduleTimeout","seekTarget","bufferLevelRule","nextFragmentRequestRule","lastFragmentRequest","topQualityIndex","lastInitQuality","replaceRequestArray","switchTrack","bufferResetInProgress","mediaRequest","liveEdgeFinder","checkPlaybackQuality","isReplacementRequest","setup","getLogger","getIsDynamic","create","resetInitialSettings","initialize","getFragmentModel","getIsTextTrack","mimeType","on","Events","TIMED_TEXT_REQUESTED","onTimedTextRequested","QUALITY_CHANGE_REQUESTED","onQualityChanged","DATA_UPDATE_STARTED","onDataUpdateStarted","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","FRAGMENT_LOADING_COMPLETED","onFragmentLoadingCompleted","STREAM_COMPLETED","onStreamCompleted","STREAM_INITIALIZED","onStreamInitialized","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","BUFFER_CLEARED","onBufferCleared","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","INIT_REQUESTED","onInitRequested","QUOTA_EXCEEDED","onQuotaExceeded","PLAYBACK_SEEKING","onPlaybackSeeking","PLAYBACK_STARTED","onPlaybackStarted","PLAYBACK_RATE_CHANGED","onPlaybackRateChanged","PLAYBACK_TIME_UPDATED","onPlaybackTimeUpdated","URL_RESOLUTION_FAILED","onURLResolutionFailed","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","isStarted","start","isBufferingCompleted","warn","debug","createPlaylistTraceMetrics","startScheduleTimer","stop","clearTimeout","hasTopQualityChanged","id","newTopQualityIndex","getTopQualityIndexFor","info","schedule","bufferController","getBufferController","isPaused","get","streaming","scheduleWhilePaused","Constants","FRAGMENTED_TEXT","TEXT","isTextEnabled","getIsBufferingCompleted","validateExecutedFragmentRequest","isReplacement","length","streamInfo","getStreamInfo","isNaN","mediaInfo","execute","isTrackTypePresent","VIDEO","getNextFragment","quality","getSwitchMode","MediaController","TRACK_SWITCH_MODE_ALWAYS_REPLACE","switchInitData","replacement","shift","isInitializationRequest","representationId","request","getIsPruningInProgress","setSeekTarget","NaN","startTime","duration","setIndexHandlerTime","delayLoadingTime","Date","getTime","setTimeToLoadDelay","manifestInfo","isDynamic","url","executeRequest","setFragmentProcessState","lowLatencyEnabled","time","safeBufferLevel","fragmentDuration","schedulingInfo","getCurrentSchedulingInfo","getRequests","state","FragmentModel","FRAGMENT_MODEL_EXECUTED","threshold","indexOf","fastSwitchModeEnabled","fastSwitchEnabled","bufferLevel","getBufferLevel","abandonmentState","getAbandonmentStateFor","trackChanged","isCurrentTrack","TRACK_SWITCH_MODE_NEVER_REPLACE","qualityChanged","MetricsConstants","ABANDON_LOAD","replaceRequest","index","value","setTimeout","e","sender","getStreamProcessor","getInitRequest","switchTrackAsked","push","mediaType","getRepresentationInfo","newQuality","undefined","Error","clearPlayListTraceMetrics","PlayListTrace","REPRESENTATION_SWITCH_STOP_REASON","completeQualityChange","trigger","item","TRACK_CHANGE_RENDERED","oldMediaInfo","newMediaInfo","adaptationIndex","QUALITY_CHANGE_RENDERED","oldQuality","error","getType","convertDataToRepresentationInfo","currentRepresentation","setTimeSyncCompleted","setLiveEdgeSeekTarget","getStreamStartTime","setSeekStartTime","liveEdge","getLiveEdge","_findRequestForLiveEdge","liveStartTime","getLiveDelay","setLiveStartTime","seek","updateManifestUpdateInfo","currentTime","presentationStartTime","latency","clientTimeOffset","getClientTimeOffset","liveDelay","computeLiveDelay","DVRWindowSize","dvrWindowSize","getFragmentRequest","ignoreIsFinished","range","serviceLocation","addExecutedRequest","fragEndTime","isSeeking","streamInfoId","getStreamId","unintended","removeExecutedRequestsAfterTime","from","syncExecutedRequestsWithBufferedRange","getBuffer","getAllBufferRanges","hasEnoughSpaceToAppend","quotaExceeded","BUFFER_EMPTY","REBUFFERING_REASON","abortRequests","seekTime","DVRWindow","end","updatePlayListTraceMetrics","playbackspeed","playbackRate","toString","getBufferTarget","finalisePlayList","reason","endTime","stopreason","pushPlayListTraceMetrics","getPlaybackRate","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"ScheduleController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport {PlayListTrace} from '../vo/metrics/PlayList';\nimport BufferLevelRule from '../rules/scheduling/BufferLevelRule';\nimport NextFragmentRequestRule from '../rules/scheduling/NextFragmentRequestRule';\nimport FragmentModel from '../models/FragmentModel';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport MediaController from './MediaController';\nimport LiveEdgeFinder from '../utils/LiveEdgeFinder';\n\nfunction ScheduleController(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const adapter = config.adapter;\n    const dashMetrics = config.dashMetrics;\n    const timelineConverter = config.timelineConverter;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const streamController = config.streamController;\n    const textController = config.textController;\n    const type = config.type;\n    const streamProcessor = config.streamProcessor;\n    const mediaController = config.mediaController;\n    const settings = config.settings;\n\n    let instance,\n        logger,\n        fragmentModel,\n        currentRepresentationInfo,\n        initialRequest,\n        isStopped,\n        isFragmentProcessingInProgress,\n        timeToLoadDelay,\n        scheduleTimeout,\n        seekTarget,\n        bufferLevelRule,\n        nextFragmentRequestRule,\n        lastFragmentRequest,\n        topQualityIndex,\n        lastInitQuality,\n        replaceRequestArray,\n        switchTrack,\n        bufferResetInProgress,\n        mediaRequest,\n        liveEdgeFinder,\n        checkPlaybackQuality,\n        isReplacementRequest;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        if (playbackController && playbackController.getIsDynamic()) {\n            liveEdgeFinder = LiveEdgeFinder(context).create({\n                timelineConverter: timelineConverter\n            });\n        }\n        resetInitialSettings();\n    }\n\n    function initialize() {\n        fragmentModel = streamProcessor.getFragmentModel();\n\n        bufferLevelRule = BufferLevelRule(context).create({\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            textController: textController,\n            settings: settings\n        });\n\n        nextFragmentRequestRule = NextFragmentRequestRule(context).create({\n            textController: textController,\n            playbackController: playbackController\n        });\n\n        if (adapter.getIsTextTrack(config.mimeType)) {\n            eventBus.on(Events.TIMED_TEXT_REQUESTED, onTimedTextRequested, this);\n        }\n\n        //eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, this);\n        eventBus.on(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.on(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.on(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.on(Events.INIT_REQUESTED, onInitRequested, this);\n        eventBus.on(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.on(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.on(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n    }\n\n    function isStarted() {\n        return (isStopped === false);\n    }\n\n    function start() {\n        if (!currentRepresentationInfo || streamProcessor.isBufferingCompleted()) {\n            logger.warn('Start denied to Schedule Controller');\n            return;\n        }\n        logger.debug('Schedule Controller starts');\n        createPlaylistTraceMetrics();\n        isStopped = false;\n\n        if (initialRequest) {\n            initialRequest = false;\n        }\n\n        startScheduleTimer(0);\n    }\n\n    function stop() {\n        if (isStopped) {\n            return;\n        }\n        logger.debug('Schedule Controller stops');\n        isStopped = true;\n        clearTimeout(scheduleTimeout);\n    }\n\n    function hasTopQualityChanged(type, id) {\n        topQualityIndex[id] = topQualityIndex[id] || {};\n        const newTopQualityIndex = abrController.getTopQualityIndexFor(type, id);\n\n        if (topQualityIndex[id][type] != newTopQualityIndex) {\n            logger.info('Top quality ' + type + ' index has changed from ' + topQualityIndex[id][type] + ' to ' + newTopQualityIndex);\n            topQualityIndex[id][type] = newTopQualityIndex;\n            return true;\n        }\n        return false;\n\n    }\n\n    function schedule() {\n        const bufferController = streamProcessor.getBufferController();\n        if (isStopped || isFragmentProcessingInProgress || !bufferController ||\n            (playbackController.isPaused() && !settings.get().streaming.scheduleWhilePaused) ||\n            ((type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) && !textController.isTextEnabled())) {\n            logger.debug('Schedule stop!');\n            return;\n        }\n\n        if (bufferController.getIsBufferingCompleted()) {\n            logger.debug('Schedule stop because buffering is completed!');\n            return;\n        }\n\n        validateExecutedFragmentRequest();\n\n        const isReplacement = replaceRequestArray.length > 0;\n        const streamInfo = streamProcessor.getStreamInfo();\n        if (bufferResetInProgress || isNaN(lastInitQuality) || switchTrack || isReplacement ||\n            hasTopQualityChanged(currentRepresentationInfo.mediaInfo.type, streamInfo.id) ||\n            bufferLevelRule.execute(streamProcessor, streamController.isTrackTypePresent(Constants.VIDEO))) {\n\n            const getNextFragment = function () {\n                if ((currentRepresentationInfo.quality !== lastInitQuality || switchTrack) && (!bufferResetInProgress)) {\n                    logger.debug('Quality has changed, get init request for representationid = ' + currentRepresentationInfo.id);\n                    if (switchTrack) {\n                        bufferResetInProgress = mediaController.getSwitchMode(type) === MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE ? true : false;\n                        logger.debug('Switch track has been asked, get init request for ' + type + ' with representationid = ' + currentRepresentationInfo.id + 'bufferResetInProgress = ' + bufferResetInProgress);\n                        streamProcessor.switchInitData(currentRepresentationInfo.id, bufferResetInProgress);\n                        switchTrack = false;\n                    } else {\n                        streamProcessor.switchInitData(currentRepresentationInfo.id);\n                    }\n                    lastInitQuality = currentRepresentationInfo.quality;\n                    checkPlaybackQuality = false;\n                } else {\n                    const replacement = replaceRequestArray.shift();\n\n                    if (replacement && replacement.isInitializationRequest()) {\n                        // To be sure the specific init segment had not already been loaded\n                        streamProcessor.switchInitData(replacement.representationId);\n                        checkPlaybackQuality = false;\n                    } else {\n                        let request;\n                        // Don't schedule next fragments while pruning to avoid buffer inconsistencies\n                        if (!streamProcessor.getBufferController().getIsPruningInProgress()) {\n                            request = nextFragmentRequestRule.execute(streamProcessor, seekTarget, replacement);\n                            setSeekTarget(NaN);\n                            if (request && !replacement) {\n                                if (!isNaN(request.startTime + request.duration)) {\n                                    streamProcessor.setIndexHandlerTime(request.startTime + request.duration);\n                                }\n                                request.delayLoadingTime = new Date().getTime() + timeToLoadDelay;\n                                setTimeToLoadDelay(0);\n                            }\n                            if (!request && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic) {\n                                logger.debug('Next fragment seems to be at the bleeding live edge and is not available yet. Rescheduling.');\n                            }\n                        }\n\n                        if (request) {\n                            logger.debug('Next fragment request url is ' + request.url);\n                            fragmentModel.executeRequest(request);\n                        } else { // Use case - Playing at the bleeding live edge and frag is not available yet. Cycle back around.\n                            setFragmentProcessState(false);\n                            startScheduleTimer(settings.get().streaming.lowLatencyEnabled ? 100 : 500);\n                        }\n                        checkPlaybackQuality = true;\n                    }\n                }\n            };\n\n            setFragmentProcessState(true);\n            if (!isReplacement && checkPlaybackQuality) {\n                abrController.checkPlaybackQuality(type);\n            }\n\n            getNextFragment();\n\n        } else {\n            startScheduleTimer(500);\n        }\n    }\n\n    function validateExecutedFragmentRequest() {\n        // Validate that the fragment request executed and appended into the source buffer is as\n        // good of quality as the current quality and is the correct media track.\n        const time = playbackController.getTime();\n        let safeBufferLevel = 1.5;\n\n        if (isNaN(currentRepresentationInfo.fragmentDuration)) { //fragmentDuration of representationInfo is not defined,\n            // call metrics function to have data in the latest scheduling info...\n            // if no metric, returns 0. In this case, rule will return false.\n            const schedulingInfo = dashMetrics.getCurrentSchedulingInfo(currentRepresentationInfo.mediaInfo.type);\n            safeBufferLevel = schedulingInfo ? schedulingInfo.duration * 1.5 : 1.5;\n        }\n        const request = fragmentModel.getRequests({\n            state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n            time: time + safeBufferLevel,\n            threshold: 0\n        })[0];\n\n        if (request && replaceRequestArray.indexOf(request) === -1 && !adapter.getIsTextTrack(type)) {\n            const fastSwitchModeEnabled = settings.get().streaming.fastSwitchEnabled;\n            const bufferLevel = streamProcessor.getBufferLevel();\n            const abandonmentState = abrController.getAbandonmentStateFor(type);\n\n            // Only replace on track switch when NEVER_REPLACE\n            const trackChanged = !mediaController.isCurrentTrack(request.mediaInfo) && mediaController.getSwitchMode(request.mediaInfo.type) === MediaController.TRACK_SWITCH_MODE_NEVER_REPLACE;\n            const qualityChanged = request.quality < currentRepresentationInfo.quality;\n\n            if (fastSwitchModeEnabled && (trackChanged || qualityChanged) && bufferLevel >= safeBufferLevel && abandonmentState !== MetricsConstants.ABANDON_LOAD) {\n                replaceRequest(request);\n                isReplacementRequest = true;\n                logger.debug('Reloading outdated fragment at index: ', request.index);\n            } else if (request.quality > currentRepresentationInfo.quality && !bufferResetInProgress) {\n                // The buffer has better quality it in then what we would request so set append point to end of buffer!!\n                setSeekTarget(playbackController.getTime() + bufferLevel);\n            }\n        }\n    }\n\n    function startScheduleTimer(value) {\n        clearTimeout(scheduleTimeout);\n\n        scheduleTimeout = setTimeout(schedule, value);\n    }\n\n    function onInitRequested(e) {\n        if (!e.sender || e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        getInitRequest(currentRepresentationInfo.quality);\n    }\n\n    function setFragmentProcessState(state) {\n        if (isFragmentProcessingInProgress !== state) {\n            isFragmentProcessingInProgress = state;\n        } else {\n            logger.debug('isFragmentProcessingInProgress is already equal to', state);\n        }\n    }\n\n    function getInitRequest(quality) {\n        const request = streamProcessor.getInitRequest(quality);\n        if (request) {\n            setFragmentProcessState(true);\n            fragmentModel.executeRequest(request);\n        }\n    }\n\n    function switchTrackAsked() {\n        switchTrack = true;\n    }\n\n    function replaceRequest(request) {\n        replaceRequestArray.push(request);\n    }\n\n    function onQualityChanged(e) {\n        if (type !== e.mediaType || streamProcessor.getStreamInfo().id !== e.streamInfo.id) {\n            return;\n        }\n\n        currentRepresentationInfo = streamProcessor.getRepresentationInfo(e.newQuality);\n\n        if (currentRepresentationInfo === null || currentRepresentationInfo === undefined) {\n            throw new Error('Unexpected error! - currentRepresentationInfo is null or undefined');\n        }\n\n        clearPlayListTraceMetrics(new Date(), PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON);\n        createPlaylistTraceMetrics();\n    }\n\n    function completeQualityChange(trigger) {\n        if (playbackController && fragmentModel) {\n            const item = fragmentModel.getRequests({\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n                time: playbackController.getTime(),\n                threshold: 0\n            })[0];\n            if (item && playbackController.getTime() >= item.startTime) {\n                if ((!lastFragmentRequest.mediaInfo || (item.mediaInfo.type === lastFragmentRequest.mediaInfo.type && item.mediaInfo.id !== lastFragmentRequest.mediaInfo.id)) && trigger) {\n                    eventBus.trigger(Events.TRACK_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldMediaInfo: lastFragmentRequest.mediaInfo,\n                        newMediaInfo: item.mediaInfo\n                    });\n                }\n                if ((item.quality !== lastFragmentRequest.quality || item.adaptationIndex !== lastFragmentRequest.adaptationIndex) && trigger) {\n                    eventBus.trigger(Events.QUALITY_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldQuality: lastFragmentRequest.quality,\n                        newQuality: item.quality\n                    });\n                }\n                lastFragmentRequest = {\n                    mediaInfo: item.mediaInfo,\n                    quality: item.quality,\n                    adaptationIndex: item.adaptationIndex\n                };\n            }\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.error || e.sender.getType() !== streamProcessor.getType()) {\n            return;\n        }\n\n        currentRepresentationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\n    }\n\n    function onStreamInitialized(e) {\n        if (!e.streamInfo || streamProcessor.getStreamInfo().id !== e.streamInfo.id) {\n            return;\n        }\n\n        currentRepresentationInfo = streamProcessor.getRepresentationInfo();\n\n        if (initialRequest) {\n            if (playbackController.getIsDynamic()) {\n                timelineConverter.setTimeSyncCompleted(true);\n                setLiveEdgeSeekTarget();\n            } else {\n                setSeekTarget(playbackController.getStreamStartTime(false));\n                streamProcessor.getBufferController().setSeekStartTime(seekTarget);\n            }\n        }\n\n        if (isStopped) {\n            start();\n        }\n    }\n\n    function setLiveEdgeSeekTarget() {\n        if (liveEdgeFinder) {\n            const liveEdge = liveEdgeFinder.getLiveEdge(streamProcessor.getRepresentationInfo());\n            let request = _findRequestForLiveEdge(liveEdge);\n\n            if (request) {\n                // When low latency mode is selected but browser doesn't support fetch\n                // start at the beginning of the segment to avoid consuming the whole buffer\n                if (settings.get().streaming.lowLatencyEnabled) {\n                    const liveStartTime = request.duration < mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay();\n                    playbackController.setLiveStartTime(liveStartTime);\n                } else {\n                    playbackController.setLiveStartTime(request.startTime);\n                }\n            } else {\n                logger.debug('setLiveEdgeSeekTarget : getFragmentRequest returned undefined request object');\n            }\n            setSeekTarget(playbackController.getStreamStartTime(false, liveEdge));\n            streamProcessor.getBufferController().setSeekStartTime(seekTarget);\n\n            //special use case for multi period stream. If the startTime is out of the current period, send a seek command.\n            //in onPlaybackSeeking callback (StreamController), the detection of switch stream is done.\n            if (seekTarget > (currentRepresentationInfo.mediaInfo.streamInfo.start + currentRepresentationInfo.mediaInfo.streamInfo.duration)) {\n                playbackController.seek(seekTarget);\n            }\n\n            dashMetrics.updateManifestUpdateInfo({\n                currentTime: seekTarget,\n                presentationStartTime: liveEdge,\n                latency: liveEdge - seekTarget,\n                clientTimeOffset: timelineConverter.getClientTimeOffset()\n            });\n        }\n    }\n\n    function _findRequestForLiveEdge(liveEdge) {\n        try {\n            let request = null;\n            let liveDelay = playbackController.computeLiveDelay(currentRepresentationInfo.fragmentDuration, currentRepresentationInfo.mediaInfo.streamInfo.manifestInfo.DVRWindowSize);\n            const dvrWindowSize = !isNaN(currentRepresentationInfo.mediaInfo.streamInfo.manifestInfo.DVRWindowSize) ? currentRepresentationInfo.mediaInfo.streamInfo.manifestInfo.DVRWindowSize : liveDelay;\n\n            // Make sure that we have at least a valid request for the end of the DVR window, otherwise we might try forever\n            if (streamProcessor.getFragmentRequest(currentRepresentationInfo, liveEdge - dvrWindowSize, {\n                ignoreIsFinished: true\n            })) {\n                // Try to find a request as close as possible to the targeted live edge\n                while (!request && liveDelay <= dvrWindowSize) {\n                    let startTime = liveEdge - liveDelay;\n                    request = streamProcessor.getFragmentRequest(currentRepresentationInfo, startTime, {\n                        ignoreIsFinished: true\n                    });\n                    liveDelay += 1; // Increase by one second for each iteration\n                }\n            }\n\n            return request;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    function onStreamCompleted(e) {\n        if (e.fragmentModel !== fragmentModel) {\n            return;\n        }\n\n        stop();\n        setFragmentProcessState(false);\n        logger.info('Stream is complete');\n    }\n\n    function onFragmentLoadingCompleted(e) {\n        if (e.sender !== fragmentModel) {\n            return;\n        }\n        logger.info('OnFragmentLoadingCompleted - Url:', e.request ? e.request.url : 'undefined', e.request.range ?\n            ', Range:' + e.request.range : '');\n        if (adapter.getIsTextTrack(type)) {\n            setFragmentProcessState(false);\n        }\n\n        if (e.error && e.request.serviceLocation && !isStopped) {\n            replaceRequest(e.request);\n            setFragmentProcessState(false);\n            startScheduleTimer(0);\n        }\n\n        if (bufferResetInProgress) {\n            mediaRequest = e.request;\n        }\n    }\n\n    function onPlaybackTimeUpdated() {\n        completeQualityChange(true);\n    }\n\n    function onBytesAppended(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        if (bufferResetInProgress && !isNaN(e.startTime)) {\n            bufferResetInProgress = false;\n            fragmentModel.addExecutedRequest(mediaRequest);\n        }\n\n        setFragmentProcessState(false);\n        if (isReplacementRequest && !isNaN(e.startTime)) {\n            //replace requests process is in progress, call schedule in n seconds.\n            //it is done in order to not add a fragment at the new quality at the end of the buffer before replace process is over.\n            //Indeed, if schedule is called too early, the executed request tested is the same that the one tested during previous schedule (at the new quality).\n            const currentTime = playbackController.getTime();\n            const fragEndTime = e.startTime + currentRepresentationInfo.fragmentDuration;\n            const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\n            if ((currentTime + safeBufferLevel) >= fragEndTime) {\n                startScheduleTimer(0);\n            } else {\n                startScheduleTimer((fragEndTime - (currentTime + safeBufferLevel)) * 1000);\n            }\n            isReplacementRequest = false;\n        } else {\n            startScheduleTimer(0);\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        if (e.streamProcessor !== streamProcessor) {\n            return;\n        }\n        logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has been aborted');\n        if (!playbackController.isSeeking() && !switchTrack) {\n            logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has to be downloaded again, origin is not seeking process or switch track call');\n            replaceRequest(e.request);\n        }\n        setFragmentProcessState(false);\n        startScheduleTimer(0);\n    }\n\n    function onDataUpdateStarted(e) {\n        const streamInfo = streamProcessor.getStreamInfo();\n        const streamInfoId = streamInfo ? streamInfo.id : null;\n        if (e.sender.getType() !== streamProcessor.getType() || e.sender.getStreamId() !== streamInfoId) {\n            return;\n        }\n\n        stop();\n    }\n\n    function onBufferCleared(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        const streamInfo = streamProcessor.getStreamInfo();\n        if (streamInfo) {\n            if (e.unintended) {\n                // There was an unintended buffer remove, probably creating a gap in the buffer, remove every saved request\n                fragmentModel.removeExecutedRequestsAfterTime(e.from);\n            } else {\n                fragmentModel.syncExecutedRequestsWithBufferedRange(\n                    streamProcessor.getBufferController().getBuffer().getAllBufferRanges(),\n                    streamInfo.duration);\n            }\n        }\n\n        if (e.hasEnoughSpaceToAppend && e.quotaExceeded && isStopped) {\n            start();\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        if ((e.sender.getStreamProcessor() === streamProcessor) && e.state === MetricsConstants.BUFFER_EMPTY && !playbackController.isSeeking()) {\n            logger.info('Buffer is empty! Stalling!');\n            clearPlayListTraceMetrics(new Date(), PlayListTrace.REBUFFERING_REASON);\n        }\n    }\n\n    function onQuotaExceeded(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        stop();\n        setFragmentProcessState(false);\n    }\n\n    function onURLResolutionFailed() {\n        fragmentModel.abortRequests();\n        stop();\n    }\n\n    function onTimedTextRequested(e) {\n        const streamInfo = streamProcessor.getStreamInfo();\n        const streamInfoId = streamInfo ? streamInfo.id : null;\n        if (e.sender.getStreamId() !== streamInfoId) {\n            return;\n        }\n\n        //if subtitles are disabled, do not download subtitles file.\n        if (textController.isTextEnabled()) {\n            getInitRequest(e.index);\n        }\n    }\n\n    function onPlaybackStarted() {\n        if (isStopped || !settings.get().streaming.scheduleWhilePaused) {\n            start();\n        }\n    }\n\n    function onPlaybackSeeking(e) {\n        setSeekTarget(e.seekTime);\n        setTimeToLoadDelay(0);\n\n        if (isStopped) {\n            start();\n        }\n\n        const latency = currentRepresentationInfo.DVRWindow && playbackController ? currentRepresentationInfo.DVRWindow.end - playbackController.getTime() : NaN;\n        dashMetrics.updateManifestUpdateInfo({\n            latency: latency\n        });\n\n        //if, during the seek command, the scheduleController is waiting : stop waiting, request chunk as soon as possible\n        if (!isFragmentProcessingInProgress) {\n            startScheduleTimer(0);\n        } else {\n            logger.debug('onPlaybackSeeking, call fragmentModel.abortRequests in order to seek quicker');\n            fragmentModel.abortRequests();\n        }\n    }\n\n    function onPlaybackRateChanged(e) {\n        dashMetrics.updatePlayListTraceMetrics({playbackspeed: e.playbackRate.toString()});\n    }\n\n    function setSeekTarget(value) {\n        seekTarget = value;\n    }\n\n    function setTimeToLoadDelay(value) {\n        timeToLoadDelay = value;\n    }\n\n    function getBufferTarget() {\n        return bufferLevelRule.getBufferTarget(streamProcessor, streamController.isTrackTypePresent(Constants.VIDEO));\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function finalisePlayList(time, reason) {\n        clearPlayListTraceMetrics(time, reason);\n    }\n\n    function clearPlayListTraceMetrics(endTime, stopreason) {\n        dashMetrics.pushPlayListTraceMetrics(endTime, stopreason);\n    }\n\n    function createPlaylistTraceMetrics() {\n        if (currentRepresentationInfo) {\n            const playbackRate = playbackController.getPlaybackRate();\n            dashMetrics.createPlaylistTraceMetrics(currentRepresentationInfo.id, playbackController.getTime() * 1000, playbackRate !== null ? playbackRate.toString() : null);\n        }\n    }\n\n    function resetInitialSettings() {\n        checkPlaybackQuality = true;\n        isFragmentProcessingInProgress = false;\n        timeToLoadDelay = 0;\n        seekTarget = NaN;\n        initialRequest = true;\n        lastInitQuality = NaN;\n        lastFragmentRequest = {\n            mediaInfo: undefined,\n            quality: NaN,\n            adaptationIndex: NaN\n        };\n        topQualityIndex = {};\n        replaceRequestArray = [];\n        isStopped = true;\n        switchTrack = false;\n        bufferResetInProgress = false;\n        mediaRequest = null;\n        isReplacementRequest = false;\n    }\n\n    function reset() {\n        //eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.off(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, this);\n        eventBus.off(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.off(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.off(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n        eventBus.off(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.off(Events.INIT_REQUESTED, onInitRequested, this);\n        eventBus.off(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.off(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n        if (adapter.getIsTextTrack(type)) {\n            eventBus.off(Events.TIMED_TEXT_REQUESTED, onTimedTextRequested, this);\n        }\n\n        stop();\n        completeQualityChange(false);\n        resetInitialSettings();\n        if (liveEdgeFinder) {\n            liveEdgeFinder.reset();\n            liveEdgeFinder = null;\n        }\n    }\n\n    instance = {\n        initialize: initialize,\n        getType: getType,\n        setSeekTarget: setSeekTarget,\n        setTimeToLoadDelay: setTimeToLoadDelay,\n        replaceRequest: replaceRequest,\n        switchTrackAsked: switchTrackAsked,\n        isStarted: isStarted,\n        start: start,\n        stop: stop,\n        reset: reset,\n        getBufferTarget: getBufferTarget,\n        finalisePlayList: finalisePlayList\n    };\n\n    setup();\n\n    return instance;\n}\n\nScheduleController.__dashjs_factory_name = 'ScheduleController';\nexport default FactoryMaker.getClassFactory(ScheduleController);\n"]}