{"version":3,"sources":["../../../../src/streaming/StreamProcessor.js"],"names":["StreamProcessor","config","context","eventBus","getInstance","type","errHandler","mimeType","timelineConverter","adapter","manifestModel","mediaPlayerModel","stream","abrController","playbackController","streamController","mediaController","textController","dashMetrics","settings","boxParser","instance","mediaInfo","mediaInfoArr","bufferController","scheduleController","representationController","fragmentModel","spExternalControllers","indexHandler","setup","resetInitialSettings","on","Events","BUFFER_LEVEL_UPDATED","onBufferLevelUpdated","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","initialize","mediaSource","create","baseURLController","streamInfo","getStreamInfo","events","errors","Errors","debug","requestModifier","dashConstants","DashConstants","constants","Constants","urlUtils","getIsDynamic","registerStreamType","getFragmentController","getModel","setStreamProcessor","createBufferControllerForType","streamProcessor","streamId","id","registerExternalController","controller","push","unregisterExternalController","index","indexOf","splice","getExternalControllers","unregisterAllExternalController","reset","errored","keepBuffers","unRegisterStreamType","forEach","off","isUpdating","e","streamInfoId","sender","getType","getStreamId","error","code","SEGMENTS_UPDATE_FAILED_ERROR_CODE","addDVRMetric","getStreamProcessor","manifest","getValue","doNotUpdateDVRWindowOnBufferUpdated","manifestInfo","isDynamic","range","calcSegmentAvailabilityRange","getCurrentRepresentation","addDVRInfo","getTime","getRepresentationController","getBuffer","setBuffer","buffer","getBufferController","getFragmentModel","addInbandEvents","selectMediaInfo","newMediaInfo","newRealAdaptation","getRealAdaptation","voRepresentations","getVoRepresentations","realAdaptation","getData","maxQuality","getTopQualityIndexFor","minIdx","getMinAllowedIndexFor","quality","averageThroughput","bitrate","FRAGMENTED_TEXT","getThroughputHistory","getAverageThroughput","getInitialBitrateFor","getQualityForBitrate","getQualityFor","undefined","setMimeType","updateData","addMediaInfo","selectNewMediaInfo","getMediaInfoArr","getMediaInfo","getMediaSource","setMediaSource","dischargePreBuffer","getScheduleController","getRepresentationInfo","voRepresentation","getRepresentationForQuality","convertDataToRepresentationInfo","isBufferingCompleted","getIsBufferingCompleted","getBufferLevel","switchInitData","representationId","bufferResetEnabled","createBuffer","previousBuffers","switchTrackAsked","VIDEO","AUDIO","setIndexHandlerTime","value","setCurrentTime","getIndexHandlerTime","getCurrentTime","NaN","resetIndexHandler","resetIndex","getInitRequest","representation","getFragmentRequest","representationInfo","time","options","fragRequest","getSegmentRequestForTime","getNextSegmentRequest","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"StreamProcessor.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport DashConstants from '../dash/constants/DashConstants';\nimport BufferController from './controllers/BufferController';\nimport TextBufferController from './text/TextBufferController';\nimport ScheduleController from './controllers/ScheduleController';\nimport RepresentationController from '../dash/controllers/RepresentationController';\nimport FactoryMaker from '../core/FactoryMaker';\nimport { checkInteger } from './utils/SupervisorTools';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport DashHandler from '../dash/DashHandler';\nimport Errors from '../core/errors/Errors';\nimport Debug from '../core/Debug';\nimport RequestModifier from './utils/RequestModifier';\nimport URLUtils from '../streaming/utils/URLUtils';\n\nfunction StreamProcessor(config) {\n\n    config = config || {};\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let type = config.type;\n    let errHandler = config.errHandler;\n    let mimeType = config.mimeType;\n    let timelineConverter = config.timelineConverter;\n    let adapter = config.adapter;\n    let manifestModel = config.manifestModel;\n    let mediaPlayerModel = config.mediaPlayerModel;\n    let stream = config.stream;\n    let abrController = config.abrController;\n    let playbackController = config.playbackController;\n    let streamController = config.streamController;\n    let mediaController = config.mediaController;\n    let textController = config.textController;\n    let dashMetrics = config.dashMetrics;\n    let settings = config.settings;\n    let boxParser = config.boxParser;\n\n    let instance,\n        mediaInfo,\n        mediaInfoArr,\n        bufferController,\n        scheduleController,\n        representationController,\n        fragmentModel,\n        spExternalControllers,\n        indexHandler;\n\n    function setup() {\n        resetInitialSettings();\n\n        eventBus.on(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    }\n\n    function initialize(mediaSource) {\n        indexHandler = DashHandler(context).create({\n            type: type,\n            timelineConverter: timelineConverter,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            baseURLController: config.baseURLController,\n            errHandler: errHandler,\n            settings: settings,\n            streamInfo: getStreamInfo(),\n            boxParser: boxParser,\n            events: Events,\n            eventBus: eventBus,\n            errors: Errors,\n            debug: Debug(context).getInstance(),\n            requestModifier: RequestModifier(context).getInstance(),\n            dashConstants: DashConstants,\n            constants: Constants,\n            urlUtils: URLUtils(context).getInstance()\n        });\n\n        // initialize controllers\n        indexHandler.initialize(playbackController.getIsDynamic());\n        abrController.registerStreamType(type, instance);\n\n        fragmentModel = stream.getFragmentController().getModel(type);\n        fragmentModel.setStreamProcessor(instance);\n\n        bufferController = createBufferControllerForType(type);\n        scheduleController = ScheduleController(context).create({\n            type: type,\n            mimeType: mimeType,\n            adapter: adapter,\n            dashMetrics: dashMetrics,\n            timelineConverter: timelineConverter,\n            mediaPlayerModel: mediaPlayerModel,\n            abrController: abrController,\n            playbackController: playbackController,\n            streamController: streamController,\n            textController: textController,\n            streamProcessor: instance,\n            mediaController: mediaController,\n            settings: settings\n        });\n        representationController = RepresentationController(context).create({\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            playbackController: playbackController,\n            timelineConverter: timelineConverter,\n            type: type,\n            dashConstants: DashConstants,\n            streamId: getStreamInfo() ? getStreamInfo().id : null,\n            events: Events,\n            eventBus: eventBus,\n            errors: Errors\n        });\n        bufferController.initialize(mediaSource);\n        scheduleController.initialize();\n    }\n\n    function registerExternalController(controller) {\n        spExternalControllers.push(controller);\n    }\n\n    function unregisterExternalController(controller) {\n        var index = spExternalControllers.indexOf(controller);\n\n        if (index !== -1) {\n            spExternalControllers.splice(index, 1);\n        }\n    }\n\n    function getExternalControllers() {\n        return spExternalControllers;\n    }\n\n    function unregisterAllExternalController() {\n        spExternalControllers = [];\n    }\n\n    function resetInitialSettings() {\n        mediaInfoArr = [];\n        mediaInfo = null;\n        unregisterAllExternalController();\n    }\n\n    function reset(errored, keepBuffers) {\n        indexHandler.reset();\n\n        if (bufferController) {\n            bufferController.reset(errored, keepBuffers);\n            bufferController = null;\n        }\n\n        if (scheduleController) {\n            scheduleController.reset();\n            scheduleController = null;\n        }\n\n        if (representationController) {\n            representationController.reset();\n            representationController = null;\n        }\n\n        if (abrController) {\n            abrController.unRegisterStreamType(type);\n        }\n        spExternalControllers.forEach(function (controller) {\n            controller.reset();\n        });\n\n        eventBus.off(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n\n        resetInitialSettings();\n        type = null;\n        stream = null;\n    }\n\n    function isUpdating() {\n        return representationController ? representationController.isUpdating() : false;\n    }\n\n    function onDataUpdateCompleted(e) {\n        const streamInfo = getStreamInfo();\n        const streamInfoId = streamInfo ? streamInfo.id : null;\n        if (e.sender.getType() !== getType() || e.sender.getStreamId() !== streamInfoId || !e.error || e.error.code !== Errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE) return;\n\n        addDVRMetric();\n    }\n\n    function onBufferLevelUpdated(e) {\n        if (e.sender.getStreamProcessor() !== instance) return;\n        let manifest = manifestModel.getValue();\n        if (!manifest.doNotUpdateDVRWindowOnBufferUpdated) {\n            addDVRMetric();\n        }\n    }\n\n    function addDVRMetric() {\n        const streamInfo = getStreamInfo();\n        const manifestInfo = streamInfo ? streamInfo.manifestInfo : null;\n        const isDynamic = manifestInfo ? manifestInfo.isDynamic : null;\n        const range = timelineConverter.calcSegmentAvailabilityRange(representationController.getCurrentRepresentation(), isDynamic);\n        dashMetrics.addDVRInfo(getType(), playbackController.getTime(), manifestInfo, range);\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getRepresentationController() {\n        return representationController;\n    }\n\n    function getBuffer() {\n        return bufferController.getBuffer();\n    }\n\n    function setBuffer(buffer) {\n        bufferController.setBuffer(buffer);\n    }\n\n    function getBufferController() {\n        return bufferController;\n    }\n\n    function getFragmentModel() {\n        return fragmentModel;\n    }\n\n    function getStreamInfo() {\n        return stream ? stream.getStreamInfo() : null;\n    }\n\n    function addInbandEvents(events) {\n        if (stream) {\n            stream.addInbandEvents(events);\n        }\n    }\n\n    function selectMediaInfo(newMediaInfo) {\n        if (newMediaInfo !== mediaInfo && (!newMediaInfo || !mediaInfo || (newMediaInfo.type === mediaInfo.type))) {\n            mediaInfo = newMediaInfo;\n        }\n\n        const streamInfo = getStreamInfo();\n        const newRealAdaptation = adapter.getRealAdaptation(streamInfo, mediaInfo);\n        const voRepresentations = adapter.getVoRepresentations(mediaInfo);\n\n        if (representationController) {\n            const realAdaptation = representationController.getData();\n            const maxQuality = abrController.getTopQualityIndexFor(type, streamInfo ? streamInfo.id : null);\n            const minIdx = abrController.getMinAllowedIndexFor(type);\n\n            let quality,\n                averageThroughput;\n            let bitrate = null;\n\n            if ((realAdaptation === null || (realAdaptation.id != newRealAdaptation.id)) && type !== Constants.FRAGMENTED_TEXT) {\n                averageThroughput = abrController.getThroughputHistory().getAverageThroughput(type);\n                bitrate = averageThroughput || abrController.getInitialBitrateFor(type);\n                quality = abrController.getQualityForBitrate(mediaInfo, bitrate);\n            } else {\n                quality = abrController.getQualityFor(type);\n            }\n\n            if (minIdx !== undefined && quality < minIdx) {\n                quality = minIdx;\n            }\n            if (quality > maxQuality) {\n                quality = maxQuality;\n            }\n            indexHandler.setMimeType(mediaInfo ? mediaInfo.mimeType : null);\n            representationController.updateData(newRealAdaptation, voRepresentations, type, quality);\n        }\n    }\n\n    function addMediaInfo(newMediaInfo, selectNewMediaInfo) {\n        if (mediaInfoArr.indexOf(newMediaInfo) === -1) {\n            mediaInfoArr.push(newMediaInfo);\n        }\n\n        if (selectNewMediaInfo) {\n            this.selectMediaInfo(newMediaInfo);\n        }\n    }\n\n    function getMediaInfoArr() {\n        return mediaInfoArr;\n    }\n\n    function getMediaInfo() {\n        return mediaInfo;\n    }\n\n    function getMediaSource() {\n        return bufferController.getMediaSource();\n    }\n\n    function setMediaSource(mediaSource) {\n        bufferController.setMediaSource(mediaSource, getMediaInfo());\n    }\n\n    function dischargePreBuffer() {\n        bufferController.dischargePreBuffer();\n    }\n\n    function getScheduleController() {\n        return scheduleController;\n    }\n\n    /**\n     * Get a specific voRepresentation. If quality parameter is defined, this function will return the voRepresentation for this quality.\n     * Otherwise, this function will return the current voRepresentation used by the representationController.\n     * @param {number} quality - quality index of the voRepresentaion expected.\n     */\n    function getRepresentationInfo(quality) {\n        let voRepresentation;\n\n        if (quality !== undefined) {\n            checkInteger(quality);\n            voRepresentation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n        } else {\n            voRepresentation = representationController ? representationController.getCurrentRepresentation() : null;\n        }\n\n        return adapter.convertDataToRepresentationInfo(voRepresentation);\n    }\n\n    function isBufferingCompleted() {\n        return bufferController ? bufferController.getIsBufferingCompleted() : false;\n    }\n\n    function getBufferLevel() {\n        return bufferController ? bufferController.getBufferLevel() : 0;\n    }\n\n    function switchInitData(representationId, bufferResetEnabled) {\n        if (bufferController) {\n            const streamInfo = getStreamInfo();\n            bufferController.switchInitData(streamInfo ? streamInfo.id : null, representationId, bufferResetEnabled);\n        }\n    }\n\n    function createBuffer(previousBuffers) {\n        return (bufferController.getBuffer() || bufferController.createBuffer(mediaInfo, previousBuffers));\n    }\n\n    function switchTrackAsked() {\n        scheduleController.switchTrackAsked();\n    }\n\n    function createBufferControllerForType(type) {\n        let controller = null;\n\n        if (type === Constants.VIDEO || type === Constants.AUDIO) {\n            controller = BufferController(context).create({\n                type: type,\n                dashMetrics: dashMetrics,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestModel: manifestModel,\n                errHandler: errHandler,\n                streamController: streamController,\n                mediaController: mediaController,\n                adapter: adapter,\n                textController: textController,\n                abrController: abrController,\n                playbackController: playbackController,\n                streamProcessor: instance,\n                settings: settings\n            });\n        } else {\n            controller = TextBufferController(context).create({\n                type: type,\n                mimeType: mimeType,\n                dashMetrics: dashMetrics,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestModel: manifestModel,\n                errHandler: errHandler,\n                streamController: streamController,\n                mediaController: mediaController,\n                adapter: adapter,\n                textController: textController,\n                abrController: abrController,\n                playbackController: playbackController,\n                streamProcessor: instance,\n                settings: settings\n            });\n        }\n\n        return controller;\n    }\n\n    function setIndexHandlerTime(value) {\n        if (indexHandler) {\n            indexHandler.setCurrentTime(value);\n        }\n    }\n\n    function getIndexHandlerTime() {\n        return indexHandler ? indexHandler.getCurrentTime() : NaN;\n    }\n\n    function resetIndexHandler() {\n        if (indexHandler) {\n            indexHandler.resetIndex();\n        }\n    }\n\n    function getInitRequest(quality) {\n        checkInteger(quality);\n\n        const representation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n\n        return indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representation) : null;\n    }\n\n    function getFragmentRequest(representationInfo, time, options) {\n        let fragRequest = null;\n\n        if (indexHandler) {\n            const representation = representationController && representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null;\n\n            // if time and options are undefined, it means the next segment is requested\n            // otherwise, the segment at this specific time is requested.\n            if (time !== undefined && options !== undefined) {\n                fragRequest = indexHandler.getSegmentRequestForTime(getMediaInfo(), representation, time, options);\n            } else {\n                fragRequest = indexHandler.getNextSegmentRequest(getMediaInfo(), representation);\n            }\n        }\n\n        return fragRequest;\n    }\n\n    instance = {\n        initialize: initialize,\n        isUpdating: isUpdating,\n        getType: getType,\n        getBufferController: getBufferController,\n        getFragmentModel: getFragmentModel,\n        getScheduleController: getScheduleController,\n        getRepresentationController: getRepresentationController,\n        getRepresentationInfo: getRepresentationInfo,\n        getBufferLevel: getBufferLevel,\n        switchInitData: switchInitData,\n        isBufferingCompleted: isBufferingCompleted,\n        createBuffer: createBuffer,\n        getStreamInfo: getStreamInfo,\n        selectMediaInfo: selectMediaInfo,\n        addMediaInfo: addMediaInfo,\n        switchTrackAsked: switchTrackAsked,\n        getMediaInfoArr: getMediaInfoArr,\n        getMediaInfo: getMediaInfo,\n        getMediaSource: getMediaSource,\n        setMediaSource: setMediaSource,\n        dischargePreBuffer: dischargePreBuffer,\n        getBuffer: getBuffer,\n        setBuffer: setBuffer,\n        registerExternalController: registerExternalController,\n        unregisterExternalController: unregisterExternalController,\n        getExternalControllers: getExternalControllers,\n        unregisterAllExternalController: unregisterAllExternalController,\n        addInbandEvents: addInbandEvents,\n        setIndexHandlerTime: setIndexHandlerTime,\n        getIndexHandlerTime: getIndexHandlerTime,\n        resetIndexHandler: resetIndexHandler,\n        getInitRequest: getInitRequest,\n        getFragmentRequest: getFragmentRequest,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\nStreamProcessor.__dashjs_factory_name = 'StreamProcessor';\nexport default FactoryMaker.getClassFactory(StreamProcessor);\n"]}